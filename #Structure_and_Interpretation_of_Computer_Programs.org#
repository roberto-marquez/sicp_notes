* Structure_and_Interpretation_of_Computer_Programs
  :PROPERTIES:
  :NOTER_DOCUMENT: resources/Structure_and_Interpretation_of_Computer_Programs.pdf
  :END:

** Chapter 1: Building Abstractions With Procedures
   :PROPERTIES:
   :NOTER_PAGE: (15 . 0.55)
   :END:

*** 1.1 The Elements of Programming
    :PROPERTIES:
    :NOTER_PAGE: (18 . 0.25)
    :END:

**** DONE Exercise 1.1
   :PROPERTIES:
   :NOTER_PAGE: (29 . 0.25333333333333335)
   :END:
   What is the result printed by the interpreter for each expression?

   10                                                     result: 10
   (+ 5 3 4)                                              result: 12
   (- 9 1)                                                result: 8
   (/ 6 2)                                                result: 3
   (+ (* 2 4) (- 4 6))                                    result: 6
   (define a 3)                                           result: ;Value: a... this represents variable definition
   (define b (+ a 1))                                     result: ;Value: b... this represent function definition
   (+ a b (* a b))                                        result: 19
   (= a b)                                                result: #f
   (if (and (> b a) (< b (* a b))) b a)                   result: 4
   (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25))       result: 16
   (+ 2 (if (> b a) b a))                                 result: 6
   (* (cond ((> a b) a) ((< a b) b) (else -1)) (+ a 1))   result: 16

**** DONE Exercise 1.2
   :PROPERTIES:
   :NOTER_PAGE: (29 . 0.72)
   :END:
   Transform the following expresssion into prefix form: (5 + 4 + (3 - (3 - (6 + 4/5))))/(3(6 - 3)(3 - 7))
   #+BEGIN_SRC scheme
   (/ (+ 5
	4
	(- 2
	   (- 3
	      (+ 6 (/ 4 5)))))
     (* 3
	(- 6 2)
	(- 2 7)))
   #+END_SRC

**** DONE Exercise 1.3
   :PROPERTIES:
   :NOTER_PAGE: (29 . 0.8133333333333334)
   :END:
   Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.
   #+BEGIN_SRC scheme
  (define (max_iter list max)
    (cond ((null? list) max)
	  ((> max (car list)) (max_iter (cdr list) max))
	  (else (max_iter (cdr list) (car list)))))
  (define (max list) (max_iter list (car list)))
  (define (remove_from_list_iter element inputList outputList removed)
  (cond ((null? inputList) outputList)
        ((or removed (not (equal? element (car inputList)))) (remove_from_list_iter element (cdr inputList) (cons (car inputList) outputList) removed))
	(else (remove_from_list_iter element (cdr inputList) outputList #t)))
  )
  (define (remove_from_list element list) (remove_from_list_iter element list '() #f))
  (define (square a) (* a a))
  (define (sum_of_square_of_two_largest a b c) (+ (square (max (list a b c))) (square (max (remove_from_list (max (list a b c)) (list a b c))))))
  (sum_of_square_of_two_largest 1 2 3)
   #+END_SRC

   #+RESULTS:
   : 13

**** DONE Exercise 1.4
   :PROPERTIES:
   :NOTER_PAGE: (29 . 0.8533333333333334)
   :END:
   Observe that our model of evaluation allows for combinations whose operators 
   are compound expressions. Use this observation to describe the behavior of the following 
   procedure:
   
   (define (a-plus-abs-b a b) 
   ((if (> b 0) + -) a b))

   Answer:
   When b is greater than cero a and b get added otherwise we substract b from a (given that b would be negative this resuls in this (a -(-b)))

**** DONE Exercise 1.5
   :PROPERTIES:
   :NOTER_PAGE: (30 . 0.08)
   :END:
   Ben Bitdiddle has invented a test to determine whether the interpreter he is faced 
   with is using applicative-order evaluation or normal-order evaluation. He defines the following 
   two procedures:  
   (define (p) (p)) 
 
   (define (test x y) 
   (if (= x 0) 
   0 
   y)) 
   Then he evaluates the expression  
   (test 0 (p)) 
   What behavior will Ben observe with an interpreter that uses applicative-order evaluation? 
   What behavior will he observe with an interpreter that uses normal-order evaluation? Explain 
   your answer.

   Answer:
   Applicative Order Evaluation: It will fist evaluate the arguments of the (test 0 (p)) call and when it evaluates (p) p will call itself recursively at infinitum.
   Normal Order Evaluation: It will expand the test function before evaluating the arguments resulting in:

   (if (= 0 0) 
   0 
   (p))) 

   then the if statement will evaluate the condition (which resolves to true) and the function would finally return 0 never reaching the (p) call.

**** DONE Exercise 1.6
   :PROPERTIES:
   :NOTER_PAGE: (32 . 0.6266666666666667)
   :END:
   Alyssa P. Hacker doesn't see why if needs to be provided as a special form. 
   ``Why can't I just define it as an ordinary procedure in terms of cond?'' she asks. Alyssa's friend 
   Eva Lu Ator claims this can indeed be done, and she defines a new version of if:  
   (define (new-if predicate then-clause else-clause) 
   (cond (predicate then-clause) 
   (else else-clause))) 
   Eva demonstrates the program for Alyssa:  
   (new-if (= 2 3) 0 5) 
   5 
 
   (new-if (= 1 1) 0 5) 
   0 

   Delighted, Alyssa uses new-if to rewrite the square-root program:  

   #+BEGIN_SRC scheme
   (define (new-if predicate then-clause else-clause) 
     (cond (predicate then-clause) 
           (else else-clause)))
   
   (define (average x y) 
     (/ (+ x y) 2)) 
   
   (define (improve guess x) 
     (average guess (/ x guess))) 
   
   (define (good-enough? guess x) 
     (< (abs (- (square guess) x)) 0.001))
   
   (define (sqrt-iter guess x) 
     (new-if (good-enough? guess x) 
             guess 
             (sqrt-iter (improve guess x) 
                        x))) 
   
   (define (sqrt x) 
     (sqrt-iter 1.0 x)) 
   #+END_SRC

   What happens when Alyssa attempts to use this to compute square roots? Explain.

   The sqrt function will infinetely recurse because the new-if function within it uses applicative order evaluation.
   That means that the sqrt-iter will keep calling itself again and again even when the guess is good enough.
   This doesn't happen with the special form 'if' because it only calls sqrt-iter if the guess is not good enough.

   If the interpreter used Normal order evaluation it would not infinetely recurse because it would reach
   the 'cond' special form and that would serve to stop the infinite recursion through the condition check.

   Normal-Order-Evaluation
   (sqrt 2)
   -------------------------------------------
   (sqrt-iter 1 2)
   -------------------------------------------
   (new-if (good-enough? 1 2) 
   1 
   (sqrt-iter (improve 1 2) 2))
   -------------------------------------------
   (cond ((good-enough? 1 2) 1)               <------- here we have the cond special form that will prevent 
   (else (sqrt-iter (improve 1 2) 2)))           the execution of sqrt-iter when the guess is good enough
   
**** DONE Exercise 1.7
   :PROPERTIES:
   :NOTER_PAGE: (33 . 0.2)
   :END:
   The good-enough? test used in computing square roots will not be very effective
   for finding the square roots of very small numbers. Also, in real computers, arithmetic
   operations are almost always performed with limited precision. This makes our test inadequate
   for very large numbers. Explain these statements, with examples showing how the test fails for
   small and large numbers. An alternative strategy for implementing good-enough? is to watch
   how guess changes from one iteration to the next and to stop when the change is a very small
   fraction of the guess. Design a square-root procedure that uses this kind of end test. Does this
   work better for small and large numbers?

   For very large numbers the tolerance being so small will keep the program in an infinite loop because due to limited precission the difference between the square of the guess and the input number will never be smaller than the tolerance.
   For very small number you'll fulfill the tolerance condition way before finding a reasonable approximation for the sqrt value.

   Improved srt:
   The idea is to check whether the guess is good enough by checking how much it is changing between iterations not how close it is to the expected value
   #+BEGIN_SRC scheme
      (define (average x y) 
      (/ (+ x y) 2)) 

      (define (square x) (* x x))
   
      (define (improve guess x) 
      (average guess (/ x guess))) 

      (define (abs x) (if (< x 0) (- x) x))

      (define (good-enough? guess x) 
      (> 0.00001 (abs (- (improve guess x) guess))))
   
      (define (sqrt-iter guess x) 
      (if (good-enough? guess x) 
      guess 
      (sqrt-iter (improve guess x) 
      x)))
   
      (define (sqrt x) 
      (sqrt-iter 1 x)) 
      
      (sqrt 0.000001)
   #+END_SRC

   #+RESULTS:
   : 0.0010005538710539446

**** DONE Exercise 1.8
   :PROPERTIES:
   :NOTER_PAGE: (33 . 0.37333333333333335)
   :END:
   Newton's method for cube roots is based on the fact that if y is an approximation
   to the cube root of x, then a better approximation is given by the value: (see image in pdf)
   Use this formula to implement a cube-root procedure analogous to the square-root procedure.
   
   #+BEGIN_SRC scheme
     (define (average x y) 
     (/ (+ x y) 2)) 

     (define (square x) (* x x))

     (define (improve guess x)
       (/
	 (+ (* 2 guess)
	    (/ x (square guess)))
	 3)) 

     (define (abs x) (if (< x 0) (- x) x))

     (define (good-enough? guess x) 
     (> 0.00001 (abs (- (improve guess x) guess))))

     (define (cbrt-iter guess x) 
     (if (good-enough? guess x) 
     guess 
     (cbrt-iter (improve guess x) 
     x)))

     (define (cbrt x) 
     (cbrt-iter 1 x)) 

     (cbrt 27.0)   
   #+END_SRC

   #+RESULTS:
   : 3.0000005410641766

*** 1.2 Procedures and the Processes They Generate
     :PROPERTIES:
     :NOTER_PAGE: (39 . 0.6166666666666667)
     :END:

**** DONE Exercise 1.9
    :PROPERTIES:
    :NOTER_PAGE: (43 . 0.11666666666666667)
    :END:
    Each of the following two procedures defines a method for adding two positive
    integers in terms of the procedures inc , which increments its argument by 1, and dec , which
    decrements its argument by 1.

    Using the substitution model, illustrate the process generated by each procedure in evaluating
    (+ 4 5) . Are these processes iterative or recursive?

    Procedure 1:
    #+BEGIN_SRC scheme
      (define (+ a b)
	(if (= a 0)
	    b
	    (inc (+ (dec a) b))))
    #+END_SRC

    (+ 4 5)
    (inc (+ 3 5))
    (inc (inc (+ 2 5)))
    (inc (inc (inc (+ 1 5))))
    (inc (inc (inc (inc (+ 0 5)))))
    (inc (inc (inc (inc 5))))
    (inc (inc (inc 6)))
    (inc (inc 7))
    (inc 8)
    9
    
    This is a recursive process as evidenced by the incresing number of pending 
    operations that accumulate and then resolve after reaching the base condition.

    Procedure 2:
    #+BEGIN_SRC scheme
      (define (+ a b)
	(if (= a 0)
	    b
	    (+ (dec a) (inc b))))
    #+END_SRC
    
    (+ 4 5)
    (+ 3 6)
    (+ 2 7)
    (+ 1 8)
    (+ 0 9)
    9

    This is an iterative process as evidenced by its set of variables (in this case a and b) that fully define
    the stage in the iterations and its lack of pending operations.

**** DONE Exercise 1.10
     :PROPERTIES:
     :NOTER_PAGE: (43 . 0.4166666666666667)
     :END:

    The following procedure computes a mathematical function called
    Ackermann's function.

    #+BEGIN_SRC scheme
    (define (A x y)
    (cond ((= y 0) 0)
    ((= x 0) (* 2 y))
    ((= y 1) 2)
    (else (A (- x 1)
    (A x (- y 1))))))
    #+END_SRC
    
    What are the values of the following expressions?
    (A 1 10)   result: 1024
    (A 2 4)    result: 65536
    (A 3 3)    result: 65536

    Consider the following procedures, where A is the procedure defined above and 
    give concise mathematical definitions for the functions computed by the procedures f , g , and h
    for positive integer values of n.

    (define (f n) (A 0 n))    computes: 2*n   y=-0 -> 0 and y=1 --> 2
    (define (g n) (A 1 n))    computes: 2^n   y=-0 -> 0 and y=1 --> 2
    (define (h n) (A 2 n))    computes: 2^(2^2^2) ..... (n - 1) times y=-0 -> 0 and y=1 --> 2
    (define (k n) (* 5 n n))  computes: 5n^2

**** DONE Exercise 1.11
     :PROPERTIES:
     :NOTER_PAGE: (47 . 0.48075412411626084)
     :END:

     A function f is defined by the rule that f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n>=3.
     Write a procedure that computes f by means of a recursive process. 
     Write a procedure that computes f by means of an iterative process.

     Recursive:
     #+BEGIN_SRC scheme results: output
       (define (f n)
	 (cond ((< n 3) n)
	       (else  (+ (f (- n 1))
			 (* 2 (f (- n 2)))
			 (* 3 (f (- n 3)))))))
       (f 4)
     #+END_SRC
     
     Iterative:
     #+BEGIN_SRC scheme results: output
       (define (f_iter a b c n count)
	 (cond ((< n 3) n)
	       ((= count n) a)
	       (else (f_iter (+ a (* 2 b) (* 3 c)) a b n (+ count 1)))
	  ))
       (define (f n)
	 (f_iter 2 1 0 n 2))

       (f 4)
     #+END_SRC

**** DONE Exercise 1.12
     :PROPERTIES:
     :NOTER_PAGE: (47 . 0.5475255302435192)
     :END:

     The following pattern of numbers is called Pascal's triangle.
     The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum
     of the two numbers above it. 35 Write a procedure that computes elements of Pascal's triangle by
     means of a recursive process.

           0
         0 1 0
        0 1 1 0
       0 1 2 1 0
      0 1 3 3 1 0
     0 1 4 6 4 1 0

     (pascal row column) ===> number

     #+BEGIN_SRC scheme
       ;            0
       ;         0  1  0
       ;        |0  |1|  1|  0
       ;   0  |1  2|  1  0
       ;  0  1  |3|  3  1  0
       ; 0  1  4  6  4  1  0


       ;(pascal 3 1) => (pascal 2 0) + (pascal 2 1)
       ;(pascal 2 0) => (pascal 1 -1) + (pascal 1 0)
       ;(pascal 2 1) => (pascal 1 0) + (pascal 1 1)

       (define (pascal row column)
	 (cond  ((< row 0) 0)
		((< column 0) 0)
		((> column row ) 0)
		((and (= row 0) (= column 0)) 1)
		(else (+ (pascal (- row 1) column)
			  (pascal (- row 1) (- column 1))))))

       (pascal 4 2)
     #+END_SRC

     #+RESULTS:
     : 6

**** TODO Exercise 1.13
     :PROPERTIES:
     :NOTER_PAGE: (47 . 0.774548311076198)
     :END:

     Prove that Fib(n) is the closest integer to n / 5, where = (1 + 5)/2. Hint:
     Let = (1 - 5)/2. Use induction and the definition of the Fibonacci numbers (see
     section 1.2.2) to prove that Fib(n) = ( n - n )/ 5.

     Fib(n) = Fib(n - 1) + Fib(n - 2)

     Fib(n) = (a^n - b^n)/(5)^(1/2)

     (a^n - b^n)/(5)^(1/2) = (a^(n - 1) - b^(n - 1))/(5)^(1/2) + (a^(n -2) - b^(n -2))/(5)^(1/2)

     a^n - b^n = a^(n - 1) - b^(n - 1) + a^(n -2) - b^(n -2)

     ....
     go here for the full proof:
     https://codology.net/post/sicp-solution-exercise-1-13/

**** DONE Exercise 1.14
     :PROPERTIES:
     :NOTER_PAGE: (48 . 0.75)
     :END:

     Draw the tree illustrating the process generated by the count-change
     procedure of section 1.2.2 in making change for 11 cents. What are the orders of growth of the
     space and number of steps used by this process as the amount to be changed increases?

     #+BEGIN_SRC scheme
       (define (count-change amount)
	 (cc amount 5))
       (define (cc amount kinds-of-coins)
	 (cond ((= amount 0) 1)
	       ((or (< amount 0) (= kinds-of-coins 0)) 0)
	       (else (+ (cc amount
			    (- kinds-of-coins 1))
			(cc (- amount
			       (first-denomination kinds-of-coins))
			    kinds-of-coins)))))
       (define (first-denomination kinds-of-coins)
	 (cond ((= kinds-of-coins 1) 1)
	       ((= kinds-of-coins 2) 5)
	       ((= kinds-of-coins 3) 10)
	       ((= kinds-of-coins 4) 25)
	       ((= kinds-of-coins 5) 50)))
       (count-change 11)
     #+END_SRC

(count-change 11)
|
(cc 11 5)__
|          \
(cc 11 4)   (cc -39 5)
|       \___
|           \
(cc 11 3)   (cc -14 4)
|       \_______________________________________________________
|                                                               \
(cc 11 2)                                                      (cc 1 3)
|       \_________________________                              |     \__
|                                 \                             |        \
(cc 11 1)                        (cc 6 2)                      (cc 1 2) (cc -9 3)
|       \___                      |     \__                     |     \__
|           \                     |        \                    |        \
(cc 11 0)   (cc 10 1)            (cc 6 1) (cc 1 2)             (cc 1 1) (cc -4 2)
           / |                    /   |       |     \__            |     \__
         /   |                   /    |       |        \           |        \
(cc 10 0)   (cc 9 1)     (cc 6 0)  (cc 5 1) (cc 1 1) (cc -4 2)   (cc 1 0) (cc 0 1)
         /   |                 /      |             |     \__
        /    |                /       |             |        \
(cc 9 0)    (cc 8 1)  (cc 5 0)     (cc 4 1)     (cc 1 0) (cc 0 1)
         __/ |                    __/ |
        /    |                   /    |
(cc 8 0)    (cc 7 1)       (cc 4 0)   (cc 3 1)
         __/ |                    __/ |
        /    |                   /    |
(cc 7 0)    (cc 6 1)       (cc 3 0)   (cc 2 1)
         __/ |                    __/ |
        /    |                   /    |
(cc 6 0)    (cc 5 1)       (cc 2 0)   (cc 1 1)
         __/ |                    __/ |
        /    |                   /    |
(cc 5 0)    (cc 4 1)        (cc 1 0)   (cc 0 1)
         __/ |
        /    |
(cc 4 0)    (cc 3 1)
         __/ |
        /    |
(cc 3 0)    (cc 2 1)
         __/ |
        /    |
(cc 2 0)    (cc 1 1)
         __/ |
        /    |
(cc 1 0)    (cc 0 1)

- Space complexity:
  When we analyse the tree of calls generated by the cc procedure we can observe that the maximum
  depth of the tree is determined by the substraction of the kinds-of-coin denomination to the total amount.
  Specifically the deepest branch will be the one that contains the greatest number of uses of the lowest
  demonination coin. Worst case scenario, the one that produces the deepest branch, will be when the change
  is comprised fully of the lowest demonination coin. The number of levels for this worst case branch will
  be equal to the ratio between the amount and the lowest denomination coin (11 / 1 for this problem) plus
  the number of other types of coins available (5 in this problem).
  The worst case scenario depth for (cc amount koc) will be equal to:
  depth = amount/koc(lowest) + koc - 1 so the space complexity is linear with respect to 'amount'.

- Time complexity:
  
**** DONE Exercise 1.15
     :PROPERTIES:
     :NOTER_PAGE: (48 . 0.8166666666666667)
     :END:

     The sine of an angle (specified in radians) can be computed by making use of the approximation 
     sin(x) ~= x if x is sufficiently small, and the trigonometric identity

     sin(r) = 3 * sin(r/3) - 4 * (sin(r/3))^3

     #+BEGIN_SRC scheme
       (define (cube x) (* x x x))
       (define (p x) (- (* 3 x) (* 4 (cube x))))
       (define (sine angle)
	 (if (not (> (abs angle) 0.1))
	     angle
	     (p (sine (/ angle 3.0)))))
       (sine 0.1)
     #+END_SRC

     a. How many times is the procedure p applied when (sine 12.15) is evaluated?
     (sine 12.15)
     (p (sine (4.05)))
     (p (p (sine (1.35))))
     (p (p (p (sine (0.45)))))
     (p (p (p (p (sine (0.15))))))
     (p (p (p (p (p (sine (0.05)))))))
     (p (p (p (p (p 0.05)))))

     As we can see the procedure p is applied 5 times.

     b. What is the order of growth in space and number of steps (as a function of a) used by the
     process generated by the sine procedure when (sine a) is evaluated?

     The number of calls will be determined by the numbers of powers of 3 contained
     within number 'a' when we use 0.1 as our unit of measure.

     number_of_calls = log_3(a/0.1) = log_3(12.15/0.1) = log_3(121.5) = 4.36907....

     because we cannot make 0.36907... of a call that means we need to round up to the neares whole
     number in this case 5.
     
     As we can see in the expansion the depth of the stack (or the number of deferred operations) that
     we need to keep track of is equal to the number of times the p procedure is called, so the process
     generated by the sine function has logarithmic growth both in time and space.

**** DONE Exercise 1.16
     :PROPERTIES:
     :NOTER_PAGE: (50 . 0.7666666666666667)
     :END:
     Design a procedure that evolves an iterative exponentiation process that uses
     successive squaring and uses a logarithmic number of steps, as does fast-expt.

     #+BEGIN_SRC scheme
       ; b^n = b^n/2*b^n/2			
       ; b^n = b^((n/2)2)
       ; b^n = (b^2)^n/2

       ; b = base
       ; n = power
       ; a = result

       (define (even? n) (= (remainder n 2) 0))
       (define (square n) (* n n))
       (define (power_iter b n a)
	 (cond ((= n 0) a)
	       ((even? n) (power_iter (square b) (/ n 2) a))
	       (else       (power_iter b (- n 1) (* a b))))
	 )
       (define (power b n)
	 (power_iter b n 1))

       (power 3 3)
     #+END_SRC

**** DONE Exercise 1.17
     :PROPERTIES:
     :NOTER_PAGE: (51 . 0.03333333333333333)
     :END:
     This algorithm takes a number of steps that is linear in b . Now suppose we include, together
     with addition, operations double, which doubles an integer, and halve, which divides an (even)
     integer by 2. Using these, design a multiplication procedure analogous to fast-expt that uses
     a logarithmic number of steps.
     
     #+BEGIN_SRC scheme
       (define (even? n) (= (remainder n 2) 0))
       (define (double n) (* n 2))
       (define (halve n) (/ n 2))
       (define (multiply a b)
	 (cond ((or (= a 0) (= b 0)) 0)
	       ((= b 1) (+ a))
	       ((even? b) (double (multiply a (/ b 2))))
	       (else (+ a (multiply a (- b 1))))))

       (multiply 2 3)
     #+END_SRC

     #+RESULTS:
     : 6

**** DONE Exercise 1.18
     :PROPERTIES:
     :NOTER_PAGE: (51 . 0.3)
     :END:
     Using the results of exercises 1.16 and 1.17, devise a procedure that generates
     an iterative process for multiplying two integers in terms of adding, doubling, and halving and
     uses a logarithmic number of steps.

     #+BEGIN_SRC scheme
       ; a * b = sum(a) b times 
       ; a * b = sum(2 * a) (b/2) times if even
       ; a * b = sum(2 * a) ((b - 1)/2) + a times if odd 

       ;a b c
       ;2 2 0
       ;4 1 0

       ;a  b  c
       ;7  3  0
       ;7  2  7
       ;14 1  7

       (define (even? n) (= (remainder n 2) 0))
       (define (double n) (* n 2))
       (define (halve n) (/ n 2))
       (define (multiply_iter a b c)
	 (cond ((or (= a 0) (= b 0)) 0)
	       ((= b 1) (+ a c))
	       ((even? b) (multiply_iter (double a) (halve b) c))
	       (else (multiply_iter a (- b 1) (+ c a))))
	 )
       (define (multiply a b)
	 (multiply_iter a b 0))

       (multiply 9 10)
     #+END_SRC

**** TODO Exercise 1.19
     :PROPERTIES:
     :NOTER_PAGE: (51 . 0.36666666666666664)
     :END:
     
     #+BEGIN_SRC scheme
       (define (fib n)
	 (fib-iter 1 0 0 1 n))
       (define (fib-iter a b p q count)
	 (cond ((= count 0) b)
	       ((even? count)
		(fib-iter a
			  b
			  <??> ; compute p'
			  <??> ; compute q'
			  (/ count 2)))
	       (else (fib-iter (+ (* b q) (* a q) (* a p))
			       (+ (* b p) (* a q))
			       p
			       q
			       (- count 1)))))
     #+END_SRC

**** TODO Exercise 1.20
     :PROPERTIES:
     :NOTER_PAGE: (53 . 0.08333333333333333)
     :END:
     
     #+BEGIN_SRC scheme
       (define (gcd a b)
	 (if (= b 0)
	     a
	     (gcd b (remainder a b))))
     #+END_SRC

     Supposing normal-order evaluation:
     
     (gcd 206 40)
     if (= 40 0)...
     (gcb 40 (remainder 206 40))
     if (= (remainder 206 40))...
     (gcb (remainder 206 40) (remained 40 (remainder 206 40)))
     ...

**** DONE Exercise 1.21
     :PROPERTIES:
     :NOTER_PAGE: (55 . 0.6333333333333333)
     :END:

     #+BEGIN_SRC scheme
       (define (divides? a b)
	 (= (remainder b a) 0))
       (define (find-divisor n test-divisor)
	 (cond ((> (square test-divisor) n) n)
	       ((divides? test-divisor n) test-divisor)
	       (else (find-divisor n (+ test-divisor 1)))))
       (define (smallest-divisor n)
	 (find-divisor n 2))

       (smallest-divisor 199)
     #+END_SRC
     NOTE: Run this code within the guile. For some reason it doesn't output the result when running it from org-mode.

     (smallest-divisor 199) = 199
     (smallest-divisor 199) = 1999
     (smallest-divisor 199) = 7

**** TODO Exercise 1.22
     :PROPERTIES:
     :NOTER_PAGE: (55 . 0.6833333333333333)
     :END:

**** TODO Exercise 1.23	
     :PROPERTIES:
     :NOTER_PAGE: (56 . 0.2833333333333333)
     :END:

**** TODO Exercise 1.24
     :PROPERTIES:
     :NOTER_PAGE: (56 . 0.5)
     :END:

**** TODO Exercise 1.25
     :PROPERTIES:
     :NOTER_PAGE: (56 . 0.6)
     :END:

**** TODO Exercise 1.26
     :PROPERTIES:
     :NOTER_PAGE: (56 . 0.7666666666666667)
     :END:

**** TODO Exercise 1.27
     :PROPERTIES:
     :NOTER_PAGE: (57 . 0.2)
     :END:

**** TODO Exercise 1.28
     :PROPERTIES:
     :NOTER_PAGE: (57 . 0.3)
     :END:

*** 1.3 Formulating Abstractions with Higher-Order Procedures
    :PROPERTIES:
    :NOTER_PAGE: (60 . 0.03333333333333333)
    :END:

